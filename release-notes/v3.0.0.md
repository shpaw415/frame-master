# v3.0.0

## New Features

### Helper Utilities

Added new helper functions to `frame-master/utils` for better plugin development experience:

#### `isVerbose()`

Check if verbose mode is enabled (CLI flag `-v` or `--verbose`).

```typescript
import { isVerbose } from "frame-master/utils";

if (isVerbose()) {
  console.log("Detailed debug information...");
}
```

#### `isBuildMode()`

Check if the current process is running via `frame-master build` command.

```typescript
import { isBuildMode } from "frame-master/utils";

serverStart: {
  main: async () => {
    if (isBuildMode()) {
      // Only execute during build
      await generateStaticAssets();
    }
  };
}
```

#### `onVerbose(callback)`

Execute a callback or log a message only when verbose mode is enabled.

```typescript
import { onVerbose } from "frame-master/utils";

onVerbose(() => console.log("Debug: Processing request..."));
onVerbose("Simple log message");
```

#### `watchFile(filePath, callback, options?)`

Watch a specific file for changes and execute a callback when it changes.

```typescript
import { watchFile } from "frame-master/utils";

// Watch a config file
const watcher = await watchFile("./config.json", async (event, filename) => {
  console.log(`Config file ${event}:`, filename);
  await reloadConfig();
});

// With options
const watcher = await watchFile(
  "/path/to/data.json",
  async (event, filename, absolutePath) => {
    if (event === "change") {
      const data = await Bun.file(absolutePath).json();
      updateCache(data);
    }
  },
  { debounceDelay: 200, verbose: true }
);

// Stop watching when done
watcher.stop();
```

Returns an object with:

- `stop()` - Stop watching the file
- `isActive()` - Check if still watching

#### `reloadPlugins()`

Hot reload the entire plugin system including server routes.

```typescript
import { reloadPlugins } from "frame-master/utils";

// Manually trigger hot reload
await reloadPlugins();
```

This performs a complete reload:

1. Reloads `frame-master.config.ts` (cache-busted)
2. Reinitializes the plugin loader with new config
3. Rebuilds the singleton builder with updated plugin configurations
4. **Reloads server routes** using `server.reload()` (Bun feature)

**What can be hot-reloaded:**

- Server routes
- Fetch handler logic
- WebSocket handlers
- Plugin router hooks
- Build configurations

**What requires a cold restart (with warning):**

- Port changes
- Hostname changes
- TLS configuration changes

When critical config changes are detected, a warning message is displayed suggesting a server restart.

#### `reloadServer()`

Hot reload the HTTP server with updated configuration, including routes and handlers.

```typescript
import { reloadServer } from "frame-master/utils";

// Full hot reload including server config
await reloadServer();
```

This function:

1. Calls `reloadPlugins()` first (config, plugins, builder)
2. Rebuilds the server configuration from the new plugins
3. Applies the new config using `server.reload()` (Bun feature)

### Automatic Config Hot Reload

In dev mode (`bun dev`), Frame-Master now **automatically watches** the `frame-master.config.ts` file for changes. When you modify the config file, plugins are automatically hot-reloaded without manual intervention.

```
[Frame-Master] Config file changed, reloading plugins...
[Frame-Master] ✓ Hot reload complete
```

This enables a seamless development experience where you can:

- Add/remove plugins
- Modify plugin configurations
- Change routes
- Update server options

All without restarting the dev server (except for port/hostname/TLS changes).

---

## Breaking Changes

### Plugin `onLoad` Handlers Are Now Automatically Chained

Previously, when multiple plugins registered `onLoad` handlers that matched the same file, behavior was undefined (typically only one handler would run).

**Now, all matching handlers are automatically chained in priority order**, where each handler's output becomes the next handler's input via `args.pooled`.

**Impact:**

- If your plugin's `onLoad` handler assumes it receives the original file contents, it may now receive transformed contents from a previous handler
- Plugins that should process files independently must use different namespaces or return `preventChaining: true`

**Migration:**

```typescript
// If your handler should NOT participate in chaining:
build.onLoad(
  { filter: /\.tsx$/ },
  async (args): Promise<PooledOnLoadResult> => {
    const contents = await Bun.file(args.path).text(); // Read original from disk
    return {
      contents: transform(contents),
      loader: "tsx",
      preventChaining: true, // Stop the chain here
    };
  }
);

// If your handler SHOULD participate in chaining (recommended):
build.onLoad({ filter: /\.tsx$/ }, async (args: PooledOnLoadArgs) => {
  const { contents } = await getPooledContents(args); // Gets chained or original
  return { contents: transform(contents), loader: "tsx" };
});
```

## Bug Fixes

- Fixed single file watching in `FileSystemWatcher` - was incorrectly joining paths

## Internal

- Centralized verbose/build mode checks in `src/utils.ts`
- `bin/share.ts` now re-exports utilities from the central module
- Added `reloadBuilder()` function to `src/build/index.ts` for hot reload support
- Refactored `InitBuilder()` to use shared `createBuilderFromPlugins()` function
- Added `getPluginLoader()` getter for dynamic plugin loader access
- Added `getConfigWatcher()` and `resetInitState()` for testing
- Added `configPath()` to get the config file path
- Added automatic config file watcher in `src/server/init.ts`

### Plugin File Pool

Added a new file pooling system that enables **chained `onLoad` handlers** when multiple plugins interact with the same file type. This allows plugins to collaboratively transform files in a pipeline fashion.

#### How It Works

When multiple plugins register `onLoad` handlers for the same file filter (e.g., `/\.tsx$/`), they are now chained together in priority order:

```
File.tsx → Plugin A (priority 0) → Plugin B (priority 1) → Final Output
```

Each handler can access the previous handler's output using the `getPooledContents()` helper.

#### Usage in Plugins

Handlers can access the previous handler's result via `args.pooled`:

```typescript
import type { PooledOnLoadArgs } from "frame-master/plugin";
import type { BunPlugin } from "bun";

const myPlugin: BunPlugin = {
  name: "my-transform-plugin",
  setup(build) {
    build.onLoad({ filter: /\.tsx$/ }, async (args: PooledOnLoadArgs) => {
      // args.pooled contains previous handler's result (if chained)
      if (args.pooled) {
        console.log("Previous loader:", args.pooled.loader);
        console.log("Previous contents:", args.pooled.contents);
      }

      // Or use getPooledContents() helper for simpler code
      const { contents, loader } = await getPooledContents(args);

      // Transform the contents
      const transformed = contents + "\n// Added by my-plugin";

      return { contents: transformed, loader: "tsx" };
    });
  },
};
```

#### File Pool API

The `FilePool` class is available for advanced use cases:

```typescript
import { FilePool, wrapPluginForPool } from "frame-master/plugin";

// Create a pool
const pool = new FilePool();

// Register handlers
pool.register("plugin-a", 0, { filter: /\.css$/ }, handler1);
pool.register("plugin-b", 1, { filter: /index\.css$/ }, handler2);

// Create unified plugin with chained handlers
const unified = pool.createUnifiedPlugin("my-pool");

// Test which handlers would match a specific file
console.log(pool.testMatchingHandlers("src/index.css"));
// [{ pluginName: "plugin-a", priority: 0 }, { pluginName: "plugin-b", priority: 1 }]

console.log(pool.testMatchingHandlers("src/button.css"));
// [{ pluginName: "plugin-a", priority: 0 }] - only plugin-a matches
```

#### Automatic Pooling

Frame-Master automatically pools `onLoad` handlers in two places:

1. **Runtime plugins** (`runtimePlugins`) - Pooled when loaded via `bunfig.toml`
2. **Build plugins** (`build.buildConfig.plugins`) - Pooled when `builder.build()` is called

No manual configuration is required - just define your plugins normally and Frame-Master handles the chaining.

#### Namespace Isolation

Handlers with different namespaces are **never** chained together, even if their filters match the same file:

```typescript
// These will NOT chain (different namespaces)
pool.register(
  "plugin-a",
  0,
  { filter: /\.tsx$/, namespace: "virtual" },
  handler1
);
pool.register("plugin-b", 1, { filter: /\.tsx$/ }, handler2); // default namespace
```

#### Prevent Chaining

Handlers can stop the chain by returning `preventChaining: true`:

```typescript
import type { PooledOnLoadResult } from "frame-master/plugin";

build.onLoad(
  { filter: /\.tsx$/ },
  async (args): Promise<PooledOnLoadResult> => {
    const contents = await Bun.file(args.path).text();

    // If this is a special file, stop the chain here
    if (args.path.includes("no-transform")) {
      return {
        contents,
        loader: "tsx",
        preventChaining: true, // No more handlers will run after this
      };
    }

    return { contents: transform(contents), loader: "tsx" };
  }
);
```

This is useful when:

- A handler fully handles a file and doesn't want other plugins to modify it
- A handler detects a condition where further processing should be skipped
- Implementing "short-circuit" logic in the plugin pipeline
